var documenterSearchIndex = {"docs":
[{"location":"spacing/#Wavelet-Frequency-Spacing","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"","category":"section"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"Frequently, using a fixed ratio for scaling the wavelets results in too many large scale wavelets. There are several ways of dealing with this; in this package, the scaling factors have the form 2^a(mx+x_0)^^1_beta, for suitable choice of a,m, x_0, and beta. The user chooses beta and Q, and the rest are chosen to match the derivative at the last frequency to be ^1_Q, as in the figure.","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"using ContinuousWavelets, Plots, Wavelets, FFTW, LaTeXStrings, Logging\nusing Plots; gr();\nPlots.reset_defaults();\ndRate = 4\nwaveType = Morlet()\nΨ1 = wavelet(waveType, s=8, β =dRate, averagingLength=2)\n# sketch of how the frequencies are chosen\npyplot()\nlocs = ContinuousWavelets.polySpacing(8,Ψ1);\n#Figure 3.1\nscatter(1:length(locs), locs, legend=:bottomright, label=\"mean log frequency\", xlabel=\"Wavelet Index (x)\", ylabel= \"log-Frequency (y)\", color=:black)\nscatter!(length(locs):length(locs), locs[end:end], markersize=10, markershape=:x, color=:black, label=:none)\nfirstW, lastW, stepS = ContinuousWavelets.genSamplePoints(8,Ψ1)\nb = (dRate/Ψ1.Q)^(1 ./dRate)*(8+Ψ1.averagingLength)^((dRate-1)/dRate)\nt= range(1,stop=length(locs),step=.1)\ncurve = b .*(range(firstW,stop=(locs[end]/b)^dRate,length=length(t))).^(1 / dRate)\nplot!(t, curve, color=:blue, line=:dash, label=L\"y=a(mx+x_0)^{^1/_\\beta}\", legend=:bottomright, legendfontsize=12, xrange=(0,length(locs)+3), xticks= [1; 5:5:1+length(locs)...], yrange=(minimum(locs)-1, maximum(locs)+1), yticks=(range(floor(Int,minimum(locs)), ceil(Int,maximum(locs)),step=2),[L\"\\alpha\", (4:2:8)..., \"N.Octaves\"]))\nx = range(15, stop=28, step=.5)\nycord(x)= locs[end] .+ b/dRate*24 .^(1/dRate-1).*(x .-length(locs))\nplot!(x, ycord(x), c=:black,line=2,label=:none)\nannotate!(length(locs)-1/8, locs[end]+7.5/16, Plots.text(L\"\\frac{dy}{dx}=^{1}/_{Q}\", 11, :black, :center))\nsavefig(\"plotOfLogCentralFrequencies.svg\")","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"(Image: )","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"If beta is 1, then we have a linear relation between the index and the log-frequency, and Q gives exactly the number of wavelets per octave throughout. As beta increases, the wavelets skew more and more heavily to high frequencies. The default value is 4.","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"The user chooses beta, Q (the number of wavelets per octave at the last point), and Ave. Length (the number of octaves covered by the averaging function), and then a, m, x_0, and the total number of wavelets N_w are chosen so that:","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"The first wavelet is scaled by 2^textrmAve Length, so the curve  a(mx+x_0)^^1_beta goes through the point   (xy)=(1textrmAve Length).\nThe derivative fracmathrmdymathrmdx at the last point is  frac1Q, so the \"instantaneous\" number of wavelets x per octave y  is Q. Each type of wavelet has a maximum scaling 2^N_Octaves  returned by getNOctaves (generally half the signal length), so the final  point N_w satisfies both y(N_w) = N_Octaves and  y(N_w)=^1_Q.\nFinally, the spacing is chosen so that there are exactly Q wavelets in the last octave.","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"If you are interested in the exact computation, see the function polySpacing. As some examples of how the wavelet bank changes as we change beta:","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"\nn=2047\nΨ1 = wavelet(morl, s=8, β=1)\nd1, ξ = ContinuousWavelets.computeWavelets(n,Ψ1)\nΨ2 = wavelet(morl, s=8, β =2)\nd2, ξ = ContinuousWavelets.computeWavelets(n,Ψ2)\nΨ4 = wavelet(morl, s=8, β =4)\nd4, ξ = ContinuousWavelets.computeWavelets(n,Ψ4)\nmatchingLimits = (minimum([d1 d2 d4]), maximum([d1 d2 d4]))#hide\nplot(heatmap(1:size(d1,2), ξ, d1, color=:Greys, yaxis = (L\"\\omega\", ), xaxis = (\"wavelet index\", ), title=L\"\\beta=1\"*\" (\"*L\"\\Psi1\"*\")\", colorbar=false, clims=matchingLimits),  heatmap(1:size(d2,2), ξ, d2, color=:Greys, yticks=[], xaxis = (\"wavelet index\", ), title=L\"\\beta=2\"*\" (\"*L\"\\Psi2\"*\")\", colorbar=false, clims=matchingLimits),  heatmap(1:size(d4,2), ξ, d4,color=:Greys, yticks=[], xticks=[1, 5, 10, 14, 18], xaxis = (\"wavelet index\", ), title=L\"\\beta=4\"*\" (\"*L\"\\Psi4\"*\")\"), layout=(1,3), clims=matchingLimits, colorbar_title=L\"\\widehat{\\psi_i}\")\nsavefig(\"changeBeta.png\") #hide","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"(Image: )","category":"page"},{"location":"spacing/","page":"Wavelet Frequency Spacing","title":"Wavelet Frequency Spacing","text":"note that the low-frequency coverage increases drastically as we decrease beta.","category":"page"},{"location":"coreType/#Available-Wavelet-Families","page":"Available Wavelet Families","title":"Available Wavelet Families","text":"","category":"section"},{"location":"coreType/","page":"Available Wavelet Families","title":"Available Wavelet Families","text":"There are two tiers of wavelet types in this package. The most abstract is the ContWave type, representing a class of wavelets. This is split into several strictly continuous wavelets, and a ContOrtho<:ContWave type, which is a supertype of continuous versions of the orthogonal wavelets defined in Wavelets.jl.","category":"page"},{"location":"coreType/","page":"Available Wavelet Families","title":"Available Wavelet Families","text":"ContWave","category":"page"},{"location":"coreType/#ContinuousWavelets.ContWave","page":"Available Wavelet Families","title":"ContinuousWavelets.ContWave","text":"ContWave{Boundary,T}\n\nThe abstract type encompassing the various types of wavelets implemented in the package. The abstract type has parameters Boundary<:WaveletBoundary and T<:Number, which gives the element output type. Each has both a constructor, and a default predefined entry. These are:\n\nMorlet: A complex approximately analytic wavelet that is just a frequency   domain Gaussian with mean subtracted. Morlet(σ::T) where T<: Real. σ   gives the frequency domain variance of the mother Wavelet. As σ goes to   zero, all of the information becomes spatial. Default is morl which has   σ=2π.\npsihat(omega) propto textrme^-fracmu^22big(textrme^-(mu - omega)^2 -textrme^fracomega^2-mu^22big)\nPaul{N}: A complex analytic wavelet. pauln for n in 1:20 e.g. paul5\npsihat(omega) propto chi_omega geq 0 omega^Ntextrme^-omega\nDog{N}: Derivative of a Gaussian, where N is the number of   derivatives. dogn for n in 0:6. The Sombrero/mexican hat/Marr wavelet   is n=2.\npsihat(omega) propto omega^Ntextrme^-fracomega^22\nContOrtho{OWT}. OWT is some orthogonal wavelet of type OrthoWaveletClass   from Wavelets.jl. This uses an   explicit construction of the mother wavelet for these orthogonal wavelets   to do a continuous transform. Constructed via ContOrtho(o::W) where o   is from Wavelets.jl. Alternatively, you can get them directly as   ContOrtho objects via:\ncHaar Haar Wavelets\ncBeyl Beylkin Wavelets\ncVaid Vaidyanthan Wavelets\ncDbn Daubhechies Wavelets. n ranges from 1:Inf\ncCoifn Coiflets. n ranges from 2:2:8\ncSymn Symlets. n ranges from 4:10\ncBattn Battle-Lemarie wavelets. n ranges from 2:2:6\n\n\n\n\n\n","category":"type"},{"location":"coreType/","page":"Available Wavelet Families","title":"Available Wavelet Families","text":"using ContinuousWavelets, Plots, Wavelets, FFTW, Logging\nusing Plots; gr()\nPlots.reset_defaults()\nn= 2047;\nfunction mapTo(waveType, isReal=true,window=1:2047; d=1, kwargs...)\n\tif isReal\n\t\tc = wavelet(waveType; β=d, kwargs...)\n\t\twaves,ω = ContinuousWavelets.computeWavelets(n,c)\n\t\treturn circshift(irfft(waves,2*n,1),(1024,0))[window,:]\n\telse\n\t\tc = wavelet(waveType; β=d, kwargs...)\n\t\twaves,ω = ContinuousWavelets.computeWavelets(n,c)\n        waves = cat(waves, zeros(2047,size(waves,2)),dims=1)\n\t\treturn circshift(ifft(waves,1),(1024,0))[window,:]\n\tend\nend\ntmp = mapTo(Morlet(π),false;averagingLength=-0.2)[:,2]\np1=plot([real.(tmp) imag.(tmp)], title=\"Morlet\", labels=[\"real\" \"imaginary\"], ticks=nothing,linewidth=5)\ntmp = mapTo(paul2,false,averagingLength=-.5)[:,2]\np2=plot([real.(tmp) imag.(tmp)],title=\"Paul 2\", labels=[\"real\" \"imaginary\"],ticks=nothing,linewidth=5)\np3=plot(mapTo(dog2;averagingLength=-1.5)[:,2],title=\"derivative of gaussians (dog2)\",legend=false,ticks=nothing,linewidth=5)\np4=plot(mapTo(cHaar,true; averagingLength=1)[:,2],title=\"Haar\",legend=false,ticks=nothing,linewidth=5)\np5=plot(mapTo(cBeyl, true; d=1, averagingLength=-0)[:,2], title=\"Beylkyin\", legend=false, ticks=nothing, linewidth=5)\np6=plot(mapTo(cVaid, true; d=1, averagingLength=-0)[:,2], title=\"Vaidyanthan\", legend=false, ticks=nothing, linewidth=5)\np7=plot(mapTo(cDb2;d=1,averagingLength=-0)[:,2],title=\"Daubhechies 2\",legend=false,ticks=nothing,linewidth=5)\np8=plot(mapTo(cCoif2, true;d=1, averagingLength=-0)[:,2],title=\"Coiflet 2\",legend=false,ticks=nothing,linewidth=5)\np9=plot(mapTo(cSym4, true; d=1,averagingLength=-0)[:,2],title=\"Symlet 4\",legend=false,ticks=nothing,linewidth=5)\nk = 0600; p10=plot(mapTo(cBatt4, true, 1024-k:1024+k;d=1,averagingLength=-1)[:,2],title=\"Battle-Lemarie, 4\",legend=false,ticks=nothing,linewidth=5)\nplot(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,layout=(2,5),size=300 .*(5, 2.2))\nsavefig(\"mothers.svg\")#hide","category":"page"},{"location":"coreType/","page":"Available Wavelet Families","title":"Available Wavelet Families","text":"(Image: ) Above are examples of every mother wavelet family defined in this package; the only analytic and/or complex wavelets are the Morlet and the Paul wavelet families. Once you have chosen a type of wavelet, this is used to construct the more specific CWT, which specifies more details of the transform, such as frequency spacing, whether to include an averaging filter or not, a frame upper bound, etc.","category":"page"},{"location":"bound/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"bound/","page":"Boundary Conditions","title":"Boundary Conditions","text":"WaveletBoundary\nPerBoundary\nZPBoundary\nSymBoundary","category":"page"},{"location":"bound/#ContinuousWavelets.WaveletBoundary","page":"Boundary Conditions","title":"ContinuousWavelets.WaveletBoundary","text":"the abstract type for the various types of boundaries\n\n\n\n\n\n","category":"type"},{"location":"bound/#ContinuousWavelets.PerBoundary","page":"Boundary Conditions","title":"ContinuousWavelets.PerBoundary","text":"PerBoundary() <: WaveletBoundary\n\nstandard periodic boundary assumption made by the fft. Aliases of NaivePer and Periodic.\n\n\n\n\n\n","category":"type"},{"location":"bound/#ContinuousWavelets.ZPBoundary","page":"Boundary Conditions","title":"ContinuousWavelets.ZPBoundary","text":"ZPBoundary() <: WaveletBoundary\n\nzero pads the signal before doing an fft, rounding up to the nearest power of two. Alias of padded.\n\n\n\n\n\n","category":"type"},{"location":"bound/#ContinuousWavelets.SymBoundary","page":"Boundary Conditions","title":"ContinuousWavelets.SymBoundary","text":"SymBoundary() <: WaveletBoundary\n\nsymmetric boundary, as in the DCT type II. Repeats the edge value, which alleviates derivative discontinuities. Alias of DEFAULT_BOUNDARY and SymBound.\n\n\n\n\n\n","category":"type"},{"location":"installation/#Installation","page":"Install","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Install","title":"Install","text":"At the moment this package is unregistered, so you will have to do it the hard way. Either press ] and run","category":"page"},{"location":"installation/","page":"Install","title":"Install","text":"(@v9.9) pkg> add https://github.com/dsweber2/ContinuousWavelets.jl.git","category":"page"},{"location":"installation/","page":"Install","title":"Install","text":"or download via git e.g. git clone https://github.com/dsweber2/ContinuousWavelets.jl.git.","category":"page"},{"location":"CWTConstruction/#CWT-Construction","page":"CWT Construction","title":"CWT Construction","text":"","category":"section"},{"location":"CWTConstruction/","page":"CWT Construction","title":"CWT Construction","text":"CWT\nContinuousWavelets.wavelet(::WC) where {WC<:ContinuousWavelets.ContWaveClass}","category":"page"},{"location":"CWTConstruction/#ContinuousWavelets.CWT","page":"CWT Construction","title":"ContinuousWavelets.CWT","text":"CWT(wave::ContWaveClass, Q=8, boundary::WaveletBoundary=SymBoundary(),\naveragingType::Average = Father(), averagingLength::Int = 4, frameBound=1, p::N=Inf, β=4)\n\n\n\n\n\n","category":"type"},{"location":"CWTConstruction/#Wavelets.WT.wavelet-Tuple{WC} where WC<:ContinuousWavelets.ContWaveClass","page":"CWT Construction","title":"Wavelets.WT.wavelet","text":"wavelet(wave::ContWaveClass; Q=8, boundary::WaveletBoundary=DEFAULT_BOUNDARY,\naveragingType::Average = Father(), averagingLength = 4,\nframeBound=1, p=Inf, β=4, kwargs...)\n\nA constructor for the CWT type, using keyword rather than positional options.\n\n\n\n\n\n","category":"method"},{"location":"CWTConstruction/","page":"CWT Construction","title":"CWT Construction","text":"The ContWaveClass type defines the kind of mother and father wavelet function.  The CWT type, in contrast, defines everything else that goes into performing a continuous wavelet transform besides that choice. The function wavelet() has been overloaded to work with ContWaveClass in much the same way it works for the owts of Wavelets.jl. In more detail, the parameters, along with their defaults, are:","category":"page"},{"location":"CWTConstruction/","page":"CWT Construction","title":"CWT Construction","text":"wave::ContWaveClass: is a type of continuous wavelet, see the Available Wavelet Families.\nscalingFactor, s, or Q::Real=8.0: the number of wavelets between the octaves 2^J and 2^J+1 (defaults to 8, which is most appropriate for music and other audio). Valid range is (0infty).\nβ::Real=4.0: As using exactly Q wavelets per octave leads to excessively many low-frequency wavelets, β varies the number of wavelets per octave, with larger values of β corresponding to fewer low frequency wavelets(see Wavelet Frequency Spacing for details). Valid range is (1infty), though around β=6 the spacing is approximately linear in frequency, rather than log-frequency, and begins to become concave after that.\nboundary::WaveletBoundary=SymBoundary(): The default boundary condition is SymBoundary(), implemented by appending a flipped version of the vector at the end to eliminate edge discontinuities. See Boundary Conditions for the other possibilities. \naveragingType::Average=Father(): determines whether or not to include the averaging function, and if so, what kind of averaging. The options are\nFather: use the averaging function that corresponds to the mother Wavelet.\nDirac: use the sinc function with the appropriate width.\nNoAve: don't average. this has one fewer filters than the other averagingTypes\naveragingLength::Int=4:  the number of wavelet octaves that are covered by the averaging, \nframeBound::Real=1: gives the total norm of the whole collection, corresponding to the upper frame bound; if you don't want to impose a particular bound, set frameBound<0.\nnormalization or p::Real=Inf: the p-norm preserved as the scale changes, so if we're scaling by s, normalization has value p, and the mother wavelet is psi, then the resulting wavelet is s^1ppsi(^t_s). The default scaling, Inf gives all the same maximum value in the frequency domain. Valid range is (0infty, though p1 isn't actually preserving a norm.","category":"page"},{"location":"#ContinuousWavelets-Documentation","page":"basic usage","title":"ContinuousWavelets Documentation","text":"","category":"section"},{"location":"","page":"basic usage","title":"basic usage","text":"Originally included in Wavelets.jl, this is a fork containing the types and methods specifically for doing continuous wavelet transforms. Current methods only include 1D wavelet transforms and their inverses.","category":"page"},{"location":"","page":"basic usage","title":"basic usage","text":"The basic structure is similar to that of Wavelets.jl; first you choose one of the Available Wavelet Families of the ContWaveClass type, e.g. Morlet(2π). Then you set the general transform parameters via CWT Construction, which specifies such properties as whether to average, the scaling rate, or the boundary conditions. Finally, you perform the actual transform withcwt.","category":"page"},{"location":"","page":"basic usage","title":"basic usage","text":"using Plots; gr(); #hide\nPlots.reset_defaults(); #hide\nusing ContinuousWavelets, Plots, Wavelets, FFTW\nn=2047;\nf = testfunction(n, \"Doppler\");\np1=plot(f,legend=false,title=\"Doppler\",xlims=(0,2000));\nc = wavelet(Morlet(π), averagingType=NoAve(), β=2);\nres = ContinuousWavelets.cwt(f, c)\np2=heatmap(abs.(res)', xlabel= \"time index\", \n\tylabel=\"frequency index\",colorbar=false);\nl=@layout [a{.3h};b{.7h}]\nplot(p1,p2,layout=l);\nsavefig(\"doppler.svg\"); #hide","category":"page"},{"location":"","page":"basic usage","title":"basic usage","text":"(Image: )","category":"page"},{"location":"","page":"basic usage","title":"basic usage","text":"","category":"page"},{"location":"inverse/","page":"Inversion","title":"Inversion","text":"using ContinuousWavelets, Plots, Wavelets, FFTW, Logging\nusing Plots; gr()\nPlots.reset_defaults()","category":"page"},{"location":"inverse/#Wavelet-Inversion","page":"Inversion","title":"Wavelet Inversion","text":"","category":"section"},{"location":"inverse/","page":"Inversion","title":"Inversion","text":"The continuous wavelet transform is a redundant shift-invariant frame transform. As such, there isn't a single inverse transform, although there is a canonical pseudo-inverse. For more see, for example, chapter 5 of A Wavelet Tour of Signal Processing.","category":"page"},{"location":"inverse/","page":"Inversion","title":"Inversion","text":"In this package, we have 3 pseudo-inverses:","category":"page"},{"location":"inverse/","page":"Inversion","title":"Inversion","text":"icwt","category":"page"},{"location":"inverse/#ContinuousWavelets.icwt","page":"Inversion","title":"ContinuousWavelets.icwt","text":"icwt(res::AbstractArray, cWav::CWT, inverseStyle::InverseType=PenroseDelta())\n\nCompute the inverse wavelet transform using one of three dual frames. The default uses delta functions with weights chosen via a least squares method, the PenroseDelta() below. This is chosen as a default because the Morlet wavelets tend to fail catastrophically using the canonical dual frame (the dualFrames() type).\n\nicwt(res::AbstractArray, cWav::CWT, inverseStyle::PenroseDelta)\n\nreturn the inverse continuous wavelet transform, computed using the simple dual frame β_jδ_ji, where β_j is chosen to solve the least squares problem Wβ-1_2^2, where W is the Fourier domain representation of the cWav wavelets. In both this case and NaiveDelta(), the fourier transform of δ is the constant function, thus this least squares problem.\n\nicwt(res::AbstractArray, cWav::CWT, inverseStyle::NaiveDelta)\n\nreturn the inverse continuous wavelet transform, computed using the simple dual frame β_jδ_ji, where β_j is chosen to negate the scale factor (^1_s)^^1_p. Generally less accurate than choosing the weights using PenroseDelta. This is the method discussed in Torrence and Compo.\n\nicwt(res::AbstractArray, cWav::CWT, inverseStyle::dualFrames)\n\nreturn the inverse continuous wavelet transform, computed using the canonical dual frame tildewidehatψ = fracψ_n(ω)_nψ_n(ω)^2. The algorithm is to compute the cwt again, but using the canonical dual frame; consiquentially, it is the most computationally intensive of the three algorithms, and typically the best behaved. Will be numerically unstable if the high frequencies of all of the wavelets are too small however, and tends to fail spectacularly in this case.\n\n\n\n\n\n","category":"function"}]
}
